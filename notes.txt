Action Expressions
- Expression tree
- Prop Name + type (avoid runtime type mismatch)
  - Runtime type checking (necessary?)
- Property Matching dispatch (filter, not query)
  - Physical Scope (depends upon location/target of action)
  - No recursion (or mutual)
    - Only other funcs in scope, or down scope
    - Does this actually prevent runaways?

Ideas:
- Qi as computation driver.
  - Limits to avoid runaway damage
  - Preserve progressive disclosure, feeling of discovery
  - Cost for physical side-effects.
  - Made by sacrificing entities?
  - Stored qi
  - Scarcity breeds creativity; useful driver of game
- Entities as debugging tools.
  - Some entities/properties hard to see without special tools.
- Avoiding artificial "levels"
  - Actal skill, accumulated knowledge, and possessions drive abilities.
  - Access controls; related to qi input? Skill?
- Programs
  - Simple expression language internally
  - Intentionally obscure tiled visual language in-game
    - Different expressions in different areas/cultures?
  - Expressed as tiles, on/in objects (special chunk?)
  - Expression chunk size limits program complexity
  - Maybe special programs expressed in-world
    - E.g., moving physical objects around to express powerful programs
  - Alternate media - programs as music?
- Metaprogramming
  - Programs as entities - side-effects create new programs
- Program communication ("IPC")
  - Done through physical side-effects
  - "Big" programs created 
- Aesthetic / consistency feedback
  - Avoid "weirdness" in the world
  - Consistency depends upon broad agreement, shared illusion
  - E.g., rendering a sword as an orange confuses other players, therefore unstable
  - How to gather feedback?
- NPC scripts as programs
  - Power to rewrite NPC conversationa nnd behavior
- Gather qi from external sources -- sun, minerals, ...?
  - Certain functions + entities needed to access different sources.


Script:
- Functions: Positional arguments with return values
- Actions: Named arguments, no explicit target or return value
  - Actions maintain reference to actor?
- Actions occur in a context
  - Directly referenced entities, surrounding chunk (Area effect within chunk?)
  - Contained entities?
- All matching receivers can react to actions, by changing internal state or generating new actions.
- New actions get resolved next cycle -- inherent limits to propagation rate.
- Actions move qi
- Qi is conserved
  - Though maybe consumed ("entropy") by computation to avoid perpetual motion
- No entity references across chunks? Preserve world locality.
  - Notification when reference is broken? Clear reference?
- Allocation + collections:
  - No built-in collections; only represented by chunks and entities.
  - Entities can contain entities, but only by owning chunks.
  - No closures, so you can't abuse stack frames to allocate.
  - Provide basic functional set operations?
  - Chunks as containers -- each gets a weird "spatial bag".
    - Qi as driver of chunk + entity creation, computation, creates natural limits on allocation.

Actions
- Timer tick?
- Move, Jump? Often triggered by other procs.
- Use
- Hit
- Take
- Drop


// Weapon
[def attack [fn [attacker target]
  [damage {target: target, amt: 5, kind: blunt}]
]]

// Actor
[def damage [fn [target amt kind]
  [set target health [- [get target health] amt]]
]]

[def repair [fn [target amt]
  [set target health [+ [get target health] amt]]
]]

// Shield
[def damage [fn [target amt kind]
  [repair {target: target, amt: amt}]
]]

// Door
[def use [fn [user target]
  [if [eq [target type] door]
    [set door open [not [get door open]]]
  ]
]]

[def 'use' [fn ['user' 'obj' 'target']
  [if [and [eq [get obj 'type'] 'key']
           [eq [get target 'type'] 'door']]
    [target 'locked' false]
  ]
]]


[def player:follow [action [player]
  [let {
    portal: [player:topWith player 'portal']
  }
    [let {
      x: [get portal 'portal-x']
      y: [get portal 'portal-y']
    }
      [jump player [get portal 'portal-chunk']]
      [move player x y]
    ]
  ]
]]


[def player:follow [action [player]
  [let [
    [portal [player:topWith player 'portal']]
  ]
    [let [
      [x [get portal 'portal-x']]
      [y [get portal 'portal-y']]
    ]
      [jump player [get portal 'portal-chunk']]
      [move player x y]
    ]
  ]
]]
