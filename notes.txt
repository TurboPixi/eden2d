Action Expressionss
- Expression tree
- Prop Name + type (avoid runtime type mismatch)
  - Runtime type checking (necessary?)
- Property Matching dispatch (filter, not query)
  - Physical Scope (depends upon location/target of action)
  - No recursion (or mutual)
    - Only other funcs in scope, or down scope
    - Does this actually prevent runaways?

Types
- bool
- num
- str
- chunk (id)
- ent   (id)
- type  (of entity)

Actions
- Timer tick?
- Move, Jump? Often triggered by other procs.
- Use
- Hit
- Take
- Drop

- Mana as computation driver.
  - Limits to avoid runaway damage
  - Preserve progressive disclosure, feeling of discovery
  - Cost for physical side-effects.
  - Made by sacrificing entities?
  - Stored mana
  - Scarcity breeds creativity; useful driver of game
- Entities as debugging tools.
  - Some entities/properties hard to see without special tools.
- Avoiding artificial "levels"
  - Actal skill, accumulated knowledge, and possessions drive abilities.
  - Access controls; related to mana input? Skill?
- Programs
  - Simple expression language internally
  - Intentionally obscure tiled visual language in-game
    - Different expressions in different areas/cultures?
  - Expressed as tiles, on/in objects (special chunk?)
  - Expression chunk size limits program complexity
  - Maybe special programs expressed in-world
    - E.g., moving physical objects around to express powerful programs
  - Alternate media - programs as music?
- Metaprogramming
  - Programs as entities - side-effects create new programs
- Program communication ("IPC")
  - Done through physical side-effects
  - "Big" programs created 
- Aesthetic / consistency feedback
  - Avoid "weirdness" in the world
  - Consistency depends upon broad agreement, shared illusion
  - E.g., rendering a sword as an orange confuses other players, therefore unstable
  - How to gather feedback?
- NPC scripts as programs
  - Power to rewrite NPC conversationa nnd behavior


['def', 'portal', ['type', 'from', 'fx', 'fy', 'to', 'tx', 'ty'], [
  ['let', { ent: ['new', { chunk: ['from'], type: ['type'] }] }, [
    ['move', { ent: ['ent'], x: ['fx'], y: ['fy'] }],
    ['set', ['ent'], Var.PortalChunk, ['to']],
    ['set', ['ent'], Var.PortalX, ['tx']],
    ['set', ['ent'], Var.PortalY, ['ty']],
    ['ent']
  ]]]],

[def portal [type from fx fy to tx ty]
  [let {
    ent:[new {
      chunk:from
      type:type
    }]
  }] [
    [move {ent:ent x:fx y:fy}]
    [set ent portalChunk to]
    [set ent portalX tx]
    [set ent portalY ty]
    [ent]
  ]
]
