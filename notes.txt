Action Expressions
- Expression tree
- Prop Name + type (avoid runtime type mismatch)
  - Runtime type checking (necessary?)
- Property Matching dispatch (filter, not query)
  - Physical Scope (depends upon location/target of action)
  - No recursion (or mutual)
    - Only other funcs in scope, or down scope
    - Does this actually prevent runaways?

Ideas:
- Qi as computation driver.
  - Limits to avoid runaway damage
  - Preserve progressive disclosure, feeling of discovery
  - Cost for physical side-effects.
  - Made by sacrificing entities?
  - Stored qi
  - Scarcity breeds creativity; useful driver of game
- Entities as debugging tools.
  - Some entities/properties hard to see without special tools.
- Avoiding artificial "levels"
  - Actal skill, accumulated knowledge, and possessions drive abilities.
  - Access controls; related to qi input? Skill?
- Programs
  - Simple expression language internally
  - Intentionally obscure tiled visual language in-game
    - Different expressions in different areas/cultures?
  - Expressed as tiles, on/in objects (special chunk?)
  - Expression chunk size limits program complexity
  - Maybe special programs expressed in-world
    - E.g., moving physical objects around to express powerful programs
  - Alternate media - programs as music?
- Metaprogramming
  - Programs as entities - side-effects create new programs
- Program communication ("IPC")
  - Done through physical side-effects
  - "Big" programs created 
- Aesthetic / consistency feedback
  - Avoid "weirdness" in the world
  - Consistency depends upon broad agreement, shared illusion
  - E.g., rendering a sword as an orange confuses other players, therefore unstable
  - How to gather feedback?
- NPC scripts as programs
  - Power to rewrite NPC conversationa nnd behavior
- Gather qi from external sources -- sun, minerals, ...?
  - Certain functions + entities needed to access different sources.
- Scenario: Natural world (trees, plants) is ill because of local energy siphoning magic.
  - Should be easy to express, as a script running in chunk scope that siphons qi from plants.
  - Plant metabolism driven by qi, derived from sunlight.
- Find a way to preserve the feeling of objects being rare and special.
  E.g., a book containing code that can't be easily or cheaply copied because... reasons?


Actions
- Timer tick?
- Move, Jump? Often triggered by other procs.
- Use
- Hit
- Take
- Drop


World structure
- Stacks: Multiple things at a single location.
  - Order matters; affects rendering
  - Built-in affordance for changing order
  - Objects at each layer get veto power over things going on top of them


Script:
- Functions: Positional arguments with return values
- Actions: Named arguments, no explicit target or return value
  - Actions maintain reference to actor?
- Actions occur in a context
  - Directly referenced entities, surrounding chunk (Area effect within chunk?)
  - Contained entities?
- All matching receivers can react to actions, by changing internal state or generating new actions.
- New actions get resolved next cycle -- inherent limits to propagation rate.
- Actions move qi
- Qi is conserved
  - Though maybe consumed ("entropy") by computation to avoid perpetual motion
- No entity references across chunks? Preserve world locality.
  - Notification when reference is broken? Clear reference?
- Allocation + collections:
  - No built-in collections; only represented by chunks and entities.
  - Entities can contain entities, but only by owning chunks.
  - No closures, so you can't abuse stack frames to allocate.
  - Provide basic functional set operations?
  - Chunks as containers -- each gets a weird "spatial bag".
    - Qi as driver of chunk + entity creation, computation, creates natural limits on allocation.
- Idea: Use default values as type-ish templates?

Principles:
- Simplest possible syntax: made of lists & dicts.
  - All combinations of list + dict should be syntactically valid programs.
  - No keywords (but builtins like true & false)
- No distinction between code + data
  - Lisp-style quote/eval to treat them as equivalent.
- Identifiers are values, just like strings, numbers, etc.
- Eval all the things: If it's possible to eval it, do. Maximize dynamic insanity.
- Error early: Don't silently coerce things. Broken programs should fail quickly.
- Functions are nothing special: Just lists that follow the right structure.
- TODO: Something about scopes, dicts, params...

Symbol resolution:
- Local scope, followed by parent scopes.
- Scopes defined by 'parent' pointers (better name? scope?)
- Function stack frames get a parent scope when peeled from a dict (or list?).
  Not entirely sure of semantics here; how does the correct parent scope find its way to func application?
- Parent pointer can be set manually on dicts to create scope chains.
- How to reliably access, e.g., parent object/dict scope from within func?
  Maybe have 'self' refer to "peeled off" scope during application?
- Can we reproduce continuations with just dicts and scope pointers?
  

Constructs:

  -- primitives
  42              -- number
  "deep thought"  -- string
  true            -- boolean
  nil             -- nil

  -- symbols
  :foo           -- quoted symbol
  foo            -- symbol reference
  [:foo 42]      -- set symbol to value (current scope)
  [self :foo 42] -- set symbol to value (scoped)
  [self:foo 42]  -- equivalent to above (: separates token and associates right)

  -- lists
  [42 "deep thought" true]   -- list (evaluated)
  (42 "deep thought" true)   -- list (unevaluated)
  :[42 "deep thought" true]  -- list (unevaluated, same as (...))

  -- dicts
  {foo bar:42 baz:("list" "of" "things")}  -- dict (foo is nil)

  -- funcs
  [:fn ([* 6 9]])       -- set symbol to list (used as function)
  [foo] => 54           -- function application
  [:fn ({x} [* 6 x])]   -- function that takes a parameter
  [fn 7] => 42          -- function application with an argument
  [:fn ({x:7} [* 6 x])] -- function that takes a default parameter
  [fn] => 42            -- called without the optional argument

  -- symbols
  :foo => foo        -- quoted symbol, evaluates to the symbol itself
  [:foo]             -- apply quoted symbol with no args, evaluates to the symbol's value
  [:foo 42]          -- apply quoted symbol with one arg, assigns value to the symbol
  foo => 42          -- reference to symbol, evaluates to symbol value in the default scope (shorthand symbol reference)
  [{foo:42} :foo]    -- apply dict with symbol argument, evaluates to the dict's value at that symbol
  [{foo:42} :foo 54] -- apply dict with symbol and value args, assigns to the dict's value at that symbol
  [some-dict:foo]    -- : is a token separator, so scopes can be jammed together like this with quoted symbols

  -- evaluation and quoting
  42    => 42    -- primitive
  (42)  => (42)  -- list
  [42]  => 42    -- evaluated list
  :[42] => (42)  -- list (alternate quoting, same as (42))
  :42   => 42    -- quoted primitive evaluates to itself
  :foo  => foo   -- quoted identifier

  -- funcs in dicts
  [:thing {                          -- func in a dict, assigned to :thing
    foo: ({x} [+ x 1])
  }]
  [thing:foo]      => ((x) [+ x 1])  -- the function itself
  [[thing:foo] 42] => 43             -- get the function and apply it

  -- self
  [:thing {                          -- dict with a func that references 'self'
    x: 9
    fn: ({y} [* [self:x] y])
  }]
  [thing:fn] =>                      -- applying [thing :fn] evaluates to the func with 'self' bound explicitly
    [bind thing fn]

  -- scope
  



-- default scope
> [:val 42]             -- set val in the default scope
> val                   -- a simple identifier references it
  {foo:42}
> [:val]                -- as does the default scope
  {foo:42}
> [scope:val]           -- as does the explicit current scope
  {foo:42}


-- functions
> [:func (42)]          -- the simplest possible function
> func                  -- the function itself
  (42)
> [func]                -- apply it
  42
> [:plus-one ({arg}     -- a func with a parameter
>   [+ arg 1]
> )]
> [plus-one 42]         -- applied with an argument
  43


-- locals
> [:func ({arg}         -- a func with one parameter
>   {local: [+ arg 1]}  -- then assigns a local (in the same scope)
>   [* local 9]         -- and uses it in an expression
> )]
> [func 5]
  54


-- scopes


-- dicts with funcs
> [:obj {func: (42)}]   -- a dict with a single value that contains a function
> [obj:func]            -- applying the dict to the ident returns the function itself
  (42)
> [[obj:func]]          -- applying the result (no args) evaluates the function body
  42
> 


-- simple no-arg function (i.e., just a list)
> [:meaning-of-life (42)]
> meaning-of-life
  (42)
> [meaning-of-life]  -- 
  42


-- one-arg function (i.e., a list with a parameter dict as its first element)
[:plus-one [{arg}
  [+ arg 1]
]]

> plus-one
< [{arg} [+ arg 1]]

> [plus-one 42]
< 43


-- one-arg function with default value
[:plus-one [{arg:42}
  [+ arg 1]
]]

> [plus-one]
< 43


-- using named args
[:weird-add [{x:42 y:54}
  [+ x y]
]

> [weird-add 1]
< 55
> [weird-add {y:1}]
< 43


-- clean single-line comments

---
multi-line comments
with nice, simple delimiters,
but no nesting
---


-- define some-fn in current scope to take parameters some-num and some-int
[set some-fn ({some-num some-int optional: 42}
  -- apply do-something-=with to both parameters, returning the result
  [do-something-with some-num some-int]
)]

[some-fn 42, "foo"]                      -- apply function some-fn to parameters (42, "foo")
[some-fn {some-num: 42 some-int: "foo"}] -- apply some-fn to named parameters (params are eagerly eval'd into fn application scope)

-- define other-fn in current scope to take a single dict parameter
[set other-fn ({params}
  [do-something-with [params:some-num] [params:some-int]]
)]

[some-fn ({some-num: 42 some-int: "foo"})] -- apply some-fn to named parameters (uses parens to leave dict uneval'd)

-- use if with quoted params to execute only one path
[if [eq nasty false]
  (do-something-nasty)
  (do-something-else)
]

-- pass a list to a function.
[do-with-all (1 2 3 "foo" bar)] -- "foo" is a string; bar is an identifier that will be resolved if/when this list is evaluated.

[set do-with-all ({things"}
  -- define a local 'total', initialized to 0.
  {total: 0}

  -- do calls a fn for all the things in a list
  [do things (["thing"]         -- func takes one "thing" parameter
    [set total [+ total thing]]
  )]
)]

-- dict with a bunch of fields & functions.
[:some-dict {
  thing: 42
  other: 54

  do-something: ({arg}
    [+ arg thing]      -- dict is lexical scope for funcs (TODO: somehow?)
  )

  do-other: ({arg}
    [:thing 54]                    -- these two are equivalent
    [self:thing' 54]               --

    [log thing]                    -- as are all of these
    [log [:thing]]                 --
    [log [self:thing]]             --

    [+ [self:arg] [self:other]]    -- self refers to current context (associated when applying [some-dict:do-other])
  )
}]
