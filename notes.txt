Action Expressions
- Expression tree
- Prop Name + type (avoid runtime type mismatch)
  - Runtime type checking (necessary?)
- Property Matching dispatch (filter, not query)
  - Physical Scope (depends upon location/target of action)
  - No recursion (or mutual)
    - Only other funcs in scope, or down scope
    - Does this actually prevent runaways?

Actions
- Timer tick?
- Move, Jump? Often triggered by other procs.
- Use
- Hit
- Take
- Drop

- Mana as computation driver.
  - Limits to avoid runaway damage
  - Preserve progressive disclosure, feeling of discovery
  - Cost for physical side-effects.
  - Made by sacrificing entities?
  - Stored mana
  - Scarcity breeds creativity; useful driver of game
- Entities as debugging tools.
  - Some entities/properties hard to see without special tools.
- Avoiding artificial "levels"
  - Actal skill, accumulated knowledge, and possessions drive abilities.
  - Access controls; related to mana input? Skill?
- Programs
  - Simple expression language internally
  - Intentionally obscure tiled visual language in-game
    - Different expressions in different areas/cultures?
  - Expressed as tiles, on/in objects (special chunk?)
  - Expression chunk size limits program complexity
  - Maybe special programs expressed in-world
    - E.g., moving physical objects around to express powerful programs
  - Alternate media - programs as music?
- Metaprogramming
  - Programs as entities - side-effects create new programs
- Program communication ("IPC")
  - Done through physical side-effects
  - "Big" programs created 
- Aesthetic / consistency feedback
  - Avoid "weirdness" in the world
  - Consistency depends upon broad agreement, shared illusion
  - E.g., rendering a sword as an orange confuses other players, therefore unstable
  - How to gather feedback?
- NPC scripts as programs
  - Power to rewrite NPC conversationa nnd behavior
- Disallow long-distance communication:
  - Forces players to build systems to communicate across chunks.


Script:
- Functions: Positional arguments with return values
- Actions: Named arguments, no explicit target or return value
  - Actions maintain reference to actor?
- Actions occur in a context
  - Directly referenced entities, surrounding chunk (Area effect within chunk?)
  - Contained entities?
- All matching receivers can react to actions, by changing internal state or generating new actions.
- New actions get resolved next cycle -- inherent limits to propagation rate.
- Actions move qi
- Qi is conserved
  - Though maybe consumed ("entropy") by computation to avoid perpetual motion
- No entity references across chunks? Preserve world locality.
  - Notification when reference is broken? Clear reference?



// Weapon
[def attack [fn [attacker target]
  [damage {target: target, amt: 5, kind: blunt}]
]]

// Actor
[def damage [fn [target amt kind]
  [set target health [- [get target health] amt]]
]]

[def repair [fn [target amt]
  [set target health [+ [get target health] amt]]
]]

// Shield
[def damage [fn [target amt kind]
  [repair {target: target, amt: amt}]
]]

// Door
[def use [fn [user target]
  [if [eq [target type] door]
    [set door open [not [get door open]]]
  ]
]]

[def use [fn [user obj target]
  [if [and [eq [get obj type] 'key']
           [eq [get target type] 'door']]
    [set target locked false]
  ]
]]
